<#
.SYNOPSIS
    CVE-2026-21509 Document Analyser
    Extracts and inspects Office OOXML documents for Shell.Explorer.1 OLE indicators.

.DESCRIPTION
    This tool unzips Office documents (OOXML = ZIP), then scans every embedded
    file for byte patterns, strings, CLSIDs, and structural markers associated
    with CVE-2026-21509 (Microsoft Office OLE Security Feature Bypass).

    Designed for PowerShell 5.1 compatibility. No external modules required.

.PARAMETER Path
    Path to a single Office document (.docx, .docm, .xlsx, .xlsm, .pptx, .pptm)
    or a folder containing multiple documents.

.PARAMETER Recurse
    When Path is a directory, scan subdirectories recursively.

.PARAMETER OutputJson
    Export results as JSON to the specified file path.

.PARAMETER OutputCsv
    Export results as CSV to the specified file path.

.PARAMETER Verbose
    Show detailed per-file scan output.

.EXAMPLE
    .\Analyse-CVE202621509.ps1 -Path "C:\Evidence\suspect.docm"

.EXAMPLE
    .\Analyse-CVE202621509.ps1 -Path "C:\Quarantine" -Recurse -OutputJson "results.json"

.EXAMPLE
    .\Analyse-CVE202621509.ps1 -Path ".\document.docx" -Verbose

.NOTES
    Author  : Detection Engineering Team
    Date    : 2026-02-02
    Version : 1.0.0
    CVE     : CVE-2026-21509
    Requires: PowerShell 5.1+
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory = $true, Position = 0, HelpMessage = "Path to document or folder")]
    [string]$Path,

    [Parameter(Mandatory = $false)]
    [switch]$Recurse,

    [Parameter(Mandatory = $false)]
    [string]$OutputJson,

    [Parameter(Mandatory = $false)]
    [string]$OutputCsv
)

# ═══════════════════════════════════════════════════════════════
# CONFIGURATION — Indicators of Compromise
# ═══════════════════════════════════════════════════════════════

$Script:Config = @{

    # Shell.Explorer.1 CLSID in little-endian binary
    CLSID_Bytes = [byte[]]@(0x61, 0xF9, 0x56, 0x88, 0x0A, 0x34, 0xD0, 0x11,
                             0xA9, 0x6B, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2)

    # OLE Compound File magic bytes
    OLE_Magic   = [byte[]]@(0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1)

    # String-based indicators (case-insensitive search)
    StringIndicators = @(
        @{ Pattern = 'Shell.Explorer.1';                          Severity = 'CRITICAL'; Description = 'Shell.Explorer.1 ProgID' }
        @{ Pattern = 'Shell.Explorer.2';                          Severity = 'CRITICAL'; Description = 'Shell.Explorer.2 ProgID' }
        @{ Pattern = '{8856F961-340A-11D0-A96B-00C04FD705A2}';   Severity = 'CRITICAL'; Description = 'Shell.Explorer.1 CLSID (string form)' }
        @{ Pattern = '8856F961-340A-11D0-A96B-00C04FD705A2';     Severity = 'CRITICAL'; Description = 'Shell.Explorer.1 CLSID (no braces)' }
        @{ Pattern = 'Shell.Explorer';                            Severity = 'HIGH';     Description = 'Shell.Explorer generic reference' }
        @{ Pattern = 'ShellBrowserWindow';                        Severity = 'HIGH';     Description = 'ShellBrowserWindow COM object' }
        @{ Pattern = 'SHDocVw';                                   Severity = 'MEDIUM';   Description = 'SHDocVw library reference (IE Shell)' }
        @{ Pattern = 'InternetExplorer.Application';              Severity = 'HIGH';     Description = 'IE Application COM ProgID' }
        @{ Pattern = 'htmlfile';                                  Severity = 'MEDIUM';   Description = 'HTML file handler reference' }
        @{ Pattern = 'ieframe.dll';                               Severity = 'HIGH';     Description = 'IE frame DLL reference' }
        @{ Pattern = 'mshtml.dll';                                Severity = 'MEDIUM';   Description = 'MSHTML rendering engine reference' }
        @{ Pattern = 'urlmon.dll';                                Severity = 'MEDIUM';   Description = 'URL Moniker DLL reference' }
    )

    # Suspicious OOXML paths / filenames
    SuspiciousPaths = @(
        @{ Pattern = 'oleObject';   Severity = 'HIGH';     Description = 'OLE embedded object file' }
        @{ Pattern = 'activeX';     Severity = 'HIGH';     Description = 'ActiveX control reference' }
        @{ Pattern = 'vbaProject';  Severity = 'MEDIUM';   Description = 'VBA macro project' }
        @{ Pattern = 'embeddings';  Severity = 'MEDIUM';   Description = 'Embeddings directory present' }
        @{ Pattern = 'oledata.mso'; Severity = 'HIGH';     Description = 'OLE data stream' }
    )

    # Additional suspicious OLE CLSIDs (known abuse vectors)
    AdditionalCLSIDs = @(
        @{ Bytes = [byte[]]@(0x06, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46)
           Name = 'StdOleLink'; Severity = 'MEDIUM'; Description = 'Standard OLE Link object' }
        @{ Bytes = [byte[]]@(0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46)
           Name = 'OLE Package'; Severity = 'HIGH'; Description = 'OLE Package object (common malware vector)' }
    )

    # Supported file extensions
    SupportedExtensions = @('.docx', '.docm', '.xlsx', '.xlsm', '.pptx', '.pptm', '.dotx', '.dotm', '.potx', '.potm')
}

# ═══════════════════════════════════════════════════════════════
# HELPER FUNCTIONS
# ═══════════════════════════════════════════════════════════════

function Write-Banner {
    $banner = @"

  ╔══════════════════════════════════════════════════════════╗
  ║          CVE-2026-21509  Document Analyser               ║
  ║     Microsoft Office OLE Security Feature Bypass         ║
  ╚══════════════════════════════════════════════════════════╝
  Version : 1.0.0
  Date    : $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
  Host    : $($env:COMPUTERNAME)

"@
    Write-Host $banner -ForegroundColor Cyan
}

function Write-Finding {
    param(
        [string]$Severity,
        [string]$Message
    )

    $colours = @{
        'CRITICAL' = 'Red'
        'HIGH'     = 'Yellow'
        'MEDIUM'   = 'DarkYellow'
        'LOW'      = 'Gray'
        'INFO'     = 'DarkCyan'
    }

    $colour = if ($colours.ContainsKey($Severity)) { $colours[$Severity] } else { 'White' }
    $prefix = "  [$Severity]".PadRight(14)
    Write-Host $prefix -ForegroundColor $colour -NoNewline
    Write-Host " $Message"
}

function Get-FileHash256 {
    param([string]$FilePath)
    try {
        $hash = Get-FileHash -Path $FilePath -Algorithm SHA256 -ErrorAction Stop
        return $hash.Hash
    }
    catch {
        return "HASH_ERROR"
    }
}

function Find-BytePattern {
    <#
    .SYNOPSIS
        Searches a byte array for a given byte pattern. Returns all offsets found.
    #>
    param(
        [byte[]]$Data,
        [byte[]]$Pattern
    )

    $offsets = [System.Collections.Generic.List[int]]::new()
    if ($Data.Length -lt $Pattern.Length) { return $offsets }

    $limit = $Data.Length - $Pattern.Length
    for ($i = 0; $i -le $limit; $i++) {
        $match = $true
        for ($j = 0; $j -lt $Pattern.Length; $j++) {
            if ($Data[$i + $j] -ne $Pattern[$j]) {
                $match = $false
                break
            }
        }
        if ($match) {
            $offsets.Add($i)
        }
    }
    return $offsets
}

function Find-StringInBytes {
    <#
    .SYNOPSIS
        Searches for ASCII and Unicode (UTF-16LE) string occurrences in a byte array.
    #>
    param(
        [byte[]]$Data,
        [string]$SearchString
    )

    $results = [System.Collections.Generic.List[PSObject]]::new()

    # ASCII search
    $asciiBytes = [System.Text.Encoding]::ASCII.GetBytes($SearchString)
    $asciiOffsets = Find-BytePattern -Data $Data -Pattern $asciiBytes
    foreach ($offset in $asciiOffsets) {
        $results.Add([PSCustomObject]@{ Offset = $offset; Encoding = 'ASCII' })
    }

    # Unicode (UTF-16LE) search
    $unicodeBytes = [System.Text.Encoding]::Unicode.GetBytes($SearchString)
    $unicodeOffsets = Find-BytePattern -Data $Data -Pattern $unicodeBytes
    foreach ($offset in $unicodeOffsets) {
        $results.Add([PSCustomObject]@{ Offset = $offset; Encoding = 'UTF-16LE' })
    }

    return $results
}

function Get-HexDump {
    <#
    .SYNOPSIS
        Returns a hex dump string for context around a given offset.
    #>
    param(
        [byte[]]$Data,
        [int]$Offset,
        [int]$ContextBytes = 32
    )

    $start = [Math]::Max(0, $Offset - $ContextBytes)
    $end   = [Math]::Min($Data.Length, $Offset + $ContextBytes)
    $slice = $Data[$start..($end - 1)]

    $hexParts = $slice | ForEach-Object { '{0:X2}' -f $_ }
    $hexString = ($hexParts -join ' ')

    return "Offset 0x{0:X8}: {1}" -f $start, $hexString
}

function Get-ContentTypeAnalysis {
    <#
    .SYNOPSIS
        Parses [Content_Types].xml from OOXML for suspicious content type declarations.
    #>
    param([string]$ContentTypesPath)

    $findings = [System.Collections.Generic.List[PSObject]]::new()

    if (-not (Test-Path $ContentTypesPath)) { return $findings }

    try {
        $content = Get-Content -Path $ContentTypesPath -Raw -Encoding UTF8
        [xml]$xml = $content

        foreach ($override in $xml.Types.Override) {
            $partName    = $override.PartName
            $contentType = $override.ContentType

            # Flag OLE / ActiveX content types
            if ($contentType -match 'oleObject|activeX|vbaProject|opc-relationships') {
                $sev = if ($contentType -match 'oleObject|activeX') { 'HIGH' } else { 'MEDIUM' }
                $findings.Add([PSCustomObject]@{
                    Severity    = $sev
                    Indicator   = "ContentType: $contentType"
                    Location    = $partName
                    Description = "Suspicious content type declaration in [Content_Types].xml"
                })
            }
        }

        foreach ($default in $xml.Types.Default) {
            $ext         = $default.Extension
            $contentType = $default.ContentType

            if ($ext -match 'bin|xml' -and $contentType -match 'oleObject|activex') {
                $findings.Add([PSCustomObject]@{
                    Severity    = 'HIGH'
                    Indicator   = "Default ContentType: $ext -> $contentType"
                    Location    = '[Content_Types].xml'
                    Description = "Default type mapping references OLE/ActiveX"
                })
            }
        }
    }
    catch {
        $findings.Add([PSCustomObject]@{
            Severity    = 'LOW'
            Indicator   = "Parse error in [Content_Types].xml"
            Location    = '[Content_Types].xml'
            Description = $_.Exception.Message
        })
    }

    return $findings
}

function Get-RelationshipAnalysis {
    <#
    .SYNOPSIS
        Parses .rels files for suspicious relationship targets (OLE, ActiveX, external links).
    #>
    param([string]$RelsPath)

    $findings = [System.Collections.Generic.List[PSObject]]::new()

    if (-not (Test-Path $RelsPath)) { return $findings }

    try {
        $content = Get-Content -Path $RelsPath -Raw -Encoding UTF8
        [xml]$xml = $content

        foreach ($rel in $xml.Relationships.Relationship) {
            $type   = $rel.Type
            $target = $rel.Target
            $mode   = $rel.TargetMode

            # Flag OLE object relationships
            if ($type -match 'oleObject|activeX|control|attachedTemplate') {
                $sev = if ($type -match 'oleObject|activeX') { 'HIGH' } else { 'MEDIUM' }
                $findings.Add([PSCustomObject]@{
                    Severity    = $sev
                    Indicator   = "Relationship Type: $($type -replace '.*/','...')"
                    Location    = "$RelsPath -> $target"
                    Description = "OLE/ActiveX relationship declaration"
                })
            }

            # Flag external targets (potential C2 / template injection)
            if ($mode -eq 'External' -or $target -match '^https?://|^\\\\|^file:') {
                $findings.Add([PSCustomObject]@{
                    Severity    = 'CRITICAL'
                    Indicator   = "External target: $target"
                    Location    = $RelsPath
                    Description = "External relationship target — potential C2 or template injection"
                })
            }
        }
    }
    catch {
        $findings.Add([PSCustomObject]@{
            Severity    = 'LOW'
            Indicator   = "Parse error in .rels file"
            Location    = $RelsPath
            Description = $_.Exception.Message
        })
    }

    return $findings
}

# ═══════════════════════════════════════════════════════════════
# CORE ANALYSIS
# ═══════════════════════════════════════════════════════════════

function Invoke-DocumentAnalysis {
    <#
    .SYNOPSIS
        Main analysis function — extracts and inspects a single Office document.
    #>
    param([string]$DocumentPath)

    $result = [PSCustomObject]@{
        FilePath       = (Resolve-Path $DocumentPath).Path
        FileName       = Split-Path $DocumentPath -Leaf
        SHA256         = Get-FileHash256 -FilePath $DocumentPath
        FileSize       = (Get-Item $DocumentPath).Length
        AnalysedAt     = (Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
        IsOOXML        = $false
        IsOLECompound  = $false
        ExtractedFiles = 0
        Findings       = [System.Collections.Generic.List[PSObject]]::new()
        RiskScore      = 0
        Verdict        = 'CLEAN'
    }

    Write-Host "`n  ────────────────────────────────────────────────────" -ForegroundColor DarkGray
    Write-Host "  Analysing: " -NoNewline -ForegroundColor White
    Write-Host "$($result.FileName)" -ForegroundColor Cyan
    Write-Host "  SHA256:    $($result.SHA256)" -ForegroundColor DarkGray
    Write-Host "  Size:      $($result.FileSize) bytes" -ForegroundColor DarkGray
    Write-Host ""

    # ── Check file header ──
    $headerBytes = [byte[]]::new(8)
    $stream = [System.IO.File]::OpenRead($DocumentPath)
    try {
        [void]$stream.Read($headerBytes, 0, 8)
    }
    finally {
        $stream.Close()
    }

    $isZip = ($headerBytes[0] -eq 0x50 -and $headerBytes[1] -eq 0x4B -and
              $headerBytes[2] -eq 0x03 -and $headerBytes[3] -eq 0x04)

    $isOLE = ($headerBytes[0] -eq 0xD0 -and $headerBytes[1] -eq 0xCF -and
              $headerBytes[2] -eq 0x11 -and $headerBytes[3] -eq 0xE0)

    if ($isZip) {
        $result.IsOOXML = $true
        Write-Finding -Severity 'INFO' -Message "File format: OOXML (ZIP-based)"
    }
    elseif ($isOLE) {
        $result.IsOLECompound = $true
        Write-Finding -Severity 'MEDIUM' -Message "File format: OLE Compound Document (legacy binary format)"

        # Scan the entire file for indicators
        $allBytes = [System.IO.File]::ReadAllBytes($DocumentPath)
        Invoke-ByteScan -Data $allBytes -SourceFile $result.FileName -Findings $result.Findings
        Invoke-ScoreFindings -Result $result
        return $result
    }
    else {
        Write-Finding -Severity 'LOW' -Message "File format: Unknown (not OOXML or OLE). Skipping."
        return $result
    }

    # ── Extract OOXML (ZIP) contents ──
    $extractDir = Join-Path ([System.IO.Path]::GetTempPath()) "CVE2026_$([Guid]::NewGuid().ToString('N').Substring(0,8))"

    try {
        Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop
        [System.IO.Compression.ZipFile]::ExtractToDirectory($DocumentPath, $extractDir)
    }
    catch {
        Write-Finding -Severity 'HIGH' -Message "Failed to extract ZIP: $($_.Exception.Message)"
        $result.Findings.Add([PSCustomObject]@{
            Severity    = 'HIGH'
            Indicator   = 'ZIP extraction failure'
            Location    = $result.FileName
            Description = "Could not extract OOXML archive — may be corrupted or password-protected"
        })
        Invoke-ScoreFindings -Result $result
        return $result
    }

    # Enumerate extracted files
    $extractedFiles = Get-ChildItem -Path $extractDir -Recurse -File
    $result.ExtractedFiles = $extractedFiles.Count
    Write-Finding -Severity 'INFO' -Message "Extracted $($extractedFiles.Count) files from OOXML archive"

    # ── Phase 1: Structural analysis ──
    Write-Host ""
    Write-Host "  [Phase 1] Structural Analysis" -ForegroundColor White

    # Check [Content_Types].xml
    $contentTypesPath = Join-Path $extractDir '[Content_Types].xml'
    $ctFindings = Get-ContentTypeAnalysis -ContentTypesPath $contentTypesPath
    foreach ($f in $ctFindings) { $result.Findings.Add($f) }

    # Check all .rels files
    $relsFiles = $extractedFiles | Where-Object { $_.Extension -eq '.rels' }
    foreach ($relsFile in $relsFiles) {
        $relFindings = Get-RelationshipAnalysis -RelsPath $relsFile.FullName
        foreach ($f in $relFindings) { $result.Findings.Add($f) }
    }

    # Check for suspicious directory/file names
    foreach ($file in $extractedFiles) {
        $relativePath = $file.FullName.Substring($extractDir.Length)

        foreach ($sp in $Script:Config.SuspiciousPaths) {
            if ($relativePath -match [regex]::Escape($sp.Pattern)) {
                $finding = [PSCustomObject]@{
                    Severity    = $sp.Severity
                    Indicator   = "Suspicious path: $($sp.Pattern)"
                    Location    = $relativePath
                    Description = $sp.Description
                }
                $result.Findings.Add($finding)
                Write-Finding -Severity $sp.Severity -Message "$($sp.Description): $relativePath"
            }
        }
    }

    # ── Phase 2: Binary / string scanning ──
    Write-Host ""
    Write-Host "  [Phase 2] Binary & String Scanning" -ForegroundColor White

    foreach ($file in $extractedFiles) {
        $relativePath = $file.FullName.Substring($extractDir.Length)

        # Skip very large files (> 50MB) to avoid memory issues
        if ($file.Length -gt 50MB) {
            Write-Finding -Severity 'INFO' -Message "Skipping large file ($($file.Length) bytes): $relativePath"
            continue
        }

        try {
            $fileBytes = [System.IO.File]::ReadAllBytes($file.FullName)
        }
        catch {
            Write-Finding -Severity 'LOW' -Message "Could not read: $relativePath"
            continue
        }

        # Check if this embedded file is itself an OLE compound document
        if ($fileBytes.Length -ge 8) {
            $isEmbeddedOLE = $true
            for ($i = 0; $i -lt 8; $i++) {
                if ($fileBytes[$i] -ne $Script:Config.OLE_Magic[$i]) {
                    $isEmbeddedOLE = $false
                    break
                }
            }
            if ($isEmbeddedOLE) {
                $result.Findings.Add([PSCustomObject]@{
                    Severity    = 'HIGH'
                    Indicator   = 'Embedded OLE Compound Document'
                    Location    = $relativePath
                    Description = "File contains OLE magic bytes (D0 CF 11 E0) — embedded binary object"
                })
                Write-Finding -Severity 'HIGH' -Message "Embedded OLE compound document: $relativePath"
            }
        }

        Invoke-ByteScan -Data $fileBytes -SourceFile $relativePath -Findings $result.Findings
    }

    # ── Cleanup ──
    try {
        Remove-Item -Path $extractDir -Recurse -Force -ErrorAction SilentlyContinue
    }
    catch { }

    # ── Score and verdict ──
    Invoke-ScoreFindings -Result $result

    return $result
}

function Invoke-ByteScan {
    <#
    .SYNOPSIS
        Scans a byte array for all configured indicators (CLSID bytes, strings, additional CLSIDs).
    #>
    param(
        [byte[]]$Data,
        [string]$SourceFile,
        [System.Collections.Generic.List[PSObject]]$Findings
    )

    # Search for Shell.Explorer.1 CLSID bytes
    $clsidOffsets = Find-BytePattern -Data $Data -Pattern $Script:Config.CLSID_Bytes
    foreach ($offset in $clsidOffsets) {
        $hex = Get-HexDump -Data $Data -Offset $offset -ContextBytes 16
        $finding = [PSCustomObject]@{
            Severity    = 'CRITICAL'
            Indicator   = 'Shell.Explorer.1 CLSID (binary)'
            Location    = "$SourceFile @ offset 0x$( '{0:X8}' -f $offset )"
            Description = "Binary CLSID {8856F961-340A-11D0-A96B-00C04FD705A2} found. $hex"
        }
        $Findings.Add($finding)
        Write-Finding -Severity 'CRITICAL' -Message "Shell.Explorer.1 CLSID bytes at offset 0x$( '{0:X8}' -f $offset ) in $SourceFile"
    }

    # Search for additional suspicious CLSIDs
    foreach ($clsid in $Script:Config.AdditionalCLSIDs) {
        $offsets = Find-BytePattern -Data $Data -Pattern $clsid.Bytes
        foreach ($offset in $offsets) {
            $finding = [PSCustomObject]@{
                Severity    = $clsid.Severity
                Indicator   = "$($clsid.Name) CLSID (binary)"
                Location    = "$SourceFile @ offset 0x$( '{0:X8}' -f $offset )"
                Description = $clsid.Description
            }
            $Findings.Add($finding)
            Write-Finding -Severity $clsid.Severity -Message "$($clsid.Name) CLSID at offset 0x$( '{0:X8}' -f $offset ) in $SourceFile"
        }
    }

    # Search for string-based indicators
    foreach ($indicator in $Script:Config.StringIndicators) {
        $stringResults = Find-StringInBytes -Data $Data -SearchString $indicator.Pattern
        foreach ($sr in $stringResults) {
            $finding = [PSCustomObject]@{
                Severity    = $indicator.Severity
                Indicator   = "$($indicator.Pattern) ($($sr.Encoding))"
                Location    = "$SourceFile @ offset 0x$( '{0:X8}' -f $sr.Offset )"
                Description = $indicator.Description
            }
            $Findings.Add($finding)
            Write-Finding -Severity $indicator.Severity -Message "$($indicator.Description) ($($sr.Encoding)) at 0x$( '{0:X8}' -f $sr.Offset ) in $SourceFile"
        }
    }
}

function Invoke-ScoreFindings {
    <#
    .SYNOPSIS
        Calculates a risk score and verdict based on accumulated findings.
    #>
    param([PSCustomObject]$Result)

    $severityWeights = @{
        'CRITICAL' = 40
        'HIGH'     = 20
        'MEDIUM'   = 10
        'LOW'      = 3
        'INFO'     = 0
    }

    $score = 0
    foreach ($f in $Result.Findings) {
        $weight = if ($severityWeights.ContainsKey($f.Severity)) { $severityWeights[$f.Severity] } else { 0 }
        $score += $weight
    }

    # Cap at 100
    $Result.RiskScore = [Math]::Min($score, 100)

    # Determine verdict
    $hasCritical = ($Result.Findings | Where-Object { $_.Severity -eq 'CRITICAL' }).Count -gt 0

    if ($hasCritical -or $Result.RiskScore -ge 80) {
        $Result.Verdict = 'MALICIOUS'
    }
    elseif ($Result.RiskScore -ge 40) {
        $Result.Verdict = 'SUSPICIOUS'
    }
    elseif ($Result.RiskScore -ge 15) {
        $Result.Verdict = 'REVIEW'
    }
    else {
        $Result.Verdict = 'CLEAN'
    }
}

function Write-ResultSummary {
    param([PSCustomObject]$Result)

    $verdictColours = @{
        'MALICIOUS'  = 'Red'
        'SUSPICIOUS' = 'Yellow'
        'REVIEW'     = 'DarkYellow'
        'CLEAN'      = 'Green'
    }

    $colour = if ($verdictColours.ContainsKey($Result.Verdict)) { $verdictColours[$Result.Verdict] } else { 'White' }

    Write-Host ""
    Write-Host "  ┌──────────────────────────────────────────────────┐" -ForegroundColor $colour
    Write-Host "  │  VERDICT: " -NoNewline -ForegroundColor $colour
    Write-Host "$($Result.Verdict)".PadRight(40) -NoNewline -ForegroundColor $colour
    Write-Host "│" -ForegroundColor $colour
    Write-Host "  │  Risk Score: " -NoNewline -ForegroundColor $colour
    Write-Host "$($Result.RiskScore)/100".PadRight(37) -NoNewline -ForegroundColor $colour
    Write-Host "│" -ForegroundColor $colour
    Write-Host "  │  Findings:   " -NoNewline -ForegroundColor $colour

    $critCount = ($Result.Findings | Where-Object { $_.Severity -eq 'CRITICAL' }).Count
    $highCount = ($Result.Findings | Where-Object { $_.Severity -eq 'HIGH' }).Count
    $medCount  = ($Result.Findings | Where-Object { $_.Severity -eq 'MEDIUM' }).Count
    $lowCount  = ($Result.Findings | Where-Object { $_.Severity -eq 'LOW' }).Count

    $summary = "${critCount}C / ${highCount}H / ${medCount}M / ${lowCount}L"
    Write-Host "$($summary.PadRight(36))" -NoNewline -ForegroundColor $colour
    Write-Host "│" -ForegroundColor $colour
    Write-Host "  └──────────────────────────────────────────────────┘" -ForegroundColor $colour
}

# ═══════════════════════════════════════════════════════════════
# MAIN EXECUTION
# ═══════════════════════════════════════════════════════════════

Write-Banner

# Resolve input path
if (-not (Test-Path $Path)) {
    Write-Host "  [ERROR] Path not found: $Path" -ForegroundColor Red
    exit 1
}

$item = Get-Item $Path

# Build file list
$filesToScan = @()

if ($item.PSIsContainer) {
    $params = @{
        Path   = $Path
        File   = $true
        Filter = '*'
    }
    if ($Recurse) { $params['Recurse'] = $true }

    $allFiles = Get-ChildItem @params
    $filesToScan = $allFiles | Where-Object {
        $Script:Config.SupportedExtensions -contains $_.Extension.ToLower()
    }

    if ($filesToScan.Count -eq 0) {
        Write-Host "  [WARN] No supported Office documents found in: $Path" -ForegroundColor Yellow
        exit 0
    }

    Write-Host "  Found $($filesToScan.Count) Office document(s) to analyse" -ForegroundColor White
}
else {
    if ($Script:Config.SupportedExtensions -notcontains $item.Extension.ToLower()) {
        Write-Host "  [WARN] Unsupported file extension: $($item.Extension)" -ForegroundColor Yellow
        Write-Host "  Supported: $($Script:Config.SupportedExtensions -join ', ')" -ForegroundColor Gray
        Write-Host "  Proceeding anyway..." -ForegroundColor Gray
    }
    $filesToScan = @($item)
}

# Run analysis
$allResults = [System.Collections.Generic.List[PSObject]]::new()

foreach ($file in $filesToScan) {
    $result = Invoke-DocumentAnalysis -DocumentPath $file.FullName
    Write-ResultSummary -Result $result
    $allResults.Add($result)
}

# ── Summary report ──
if ($allResults.Count -gt 1) {
    Write-Host "`n  ════════════════════════════════════════════════════" -ForegroundColor Cyan
    Write-Host "  BATCH SUMMARY" -ForegroundColor Cyan
    Write-Host "  ════════════════════════════════════════════════════" -ForegroundColor Cyan
    Write-Host "  Total documents scanned: $($allResults.Count)" -ForegroundColor White

    $malCount  = ($allResults | Where-Object { $_.Verdict -eq 'MALICIOUS' }).Count
    $susCount  = ($allResults | Where-Object { $_.Verdict -eq 'SUSPICIOUS' }).Count
    $revCount  = ($allResults | Where-Object { $_.Verdict -eq 'REVIEW' }).Count
    $cleanCount = ($allResults | Where-Object { $_.Verdict -eq 'CLEAN' }).Count

    if ($malCount -gt 0) { Write-Host "  MALICIOUS:  $malCount" -ForegroundColor Red }
    if ($susCount -gt 0) { Write-Host "  SUSPICIOUS: $susCount" -ForegroundColor Yellow }
    if ($revCount -gt 0) { Write-Host "  REVIEW:     $revCount" -ForegroundColor DarkYellow }
    Write-Host "  CLEAN:      $cleanCount" -ForegroundColor Green
}

# ── Export results ──
$exportData = $allResults | ForEach-Object {
    [PSCustomObject]@{
        FilePath       = $_.FilePath
        FileName       = $_.FileName
        SHA256         = $_.SHA256
        FileSize       = $_.FileSize
        AnalysedAt     = $_.AnalysedAt
        IsOOXML        = $_.IsOOXML
        IsOLECompound  = $_.IsOLECompound
        ExtractedFiles = $_.ExtractedFiles
        FindingCount   = $_.Findings.Count
        RiskScore      = $_.RiskScore
        Verdict        = $_.Verdict
        Findings       = $_.Findings | ForEach-Object {
            [PSCustomObject]@{
                Severity    = $_.Severity
                Indicator   = $_.Indicator
                Location    = $_.Location
                Description = $_.Description
            }
        }
    }
}

if ($OutputJson) {
    $exportData | ConvertTo-Json -Depth 5 | Out-File -FilePath $OutputJson -Encoding UTF8
    Write-Host "`n  [OK] JSON results exported to: $OutputJson" -ForegroundColor Green
}

if ($OutputCsv) {
    # Flatten findings for CSV
    $csvData = foreach ($r in $allResults) {
        if ($r.Findings.Count -eq 0) {
            [PSCustomObject]@{
                FileName    = $r.FileName
                SHA256      = $r.SHA256
                Verdict     = $r.Verdict
                RiskScore   = $r.RiskScore
                Severity    = ''
                Indicator   = ''
                Location    = ''
                Description = ''
            }
        }
        else {
            foreach ($f in $r.Findings) {
                [PSCustomObject]@{
                    FileName    = $r.FileName
                    SHA256      = $r.SHA256
                    Verdict     = $r.Verdict
                    RiskScore   = $r.RiskScore
                    Severity    = $f.Severity
                    Indicator   = $f.Indicator
                    Location    = $f.Location
                    Description = $f.Description
                }
            }
        }
    }
    $csvData | Export-Csv -Path $OutputCsv -NoTypeInformation -Encoding UTF8
    Write-Host "`n  [OK] CSV results exported to: $OutputCsv" -ForegroundColor Green
}

Write-Host "`n  Analysis complete.`n" -ForegroundColor Cyan
